1. 셰이더에 전역 light 추가 => 일단 무조건 밝게 볼 수 있게 하기
   1. Atteunation
      일단 광원으로 부터 멀어질수록 감쇠가 발생한다
      거리 제곱에 반비례 하는 데, 그대로 적용하면 너무 어두워
      상수 값과 거리에 반비례 하는 값도 존재

   2. Intensity
      광원에 방향이 있을 때
      광원이 쏘는 방향으로부터 프레그먼트가 멀리 떨어져 있으면
      더 약한 빛을 받게 된다
      계산 방법 => LightVec 와 LightDir 을 사용

      1. LightVec = Fragment 에서 광원을 바라보는 빛 벡터
      2. LightDir = 빛이 쏘는 방향 벡터
         1. 광원이 손전등처럼 쏘는 방향이 있을 때 존재하는 값
         2. -LightDir = 광원으로 들어가는 빛의 방향
      3. LightVec 와 (-LightDir) 의 내적
         1. 내가 광원을 바라보는 시선과 광원이 바라보는 시선 사이의 각을 구할 수 있다
         2. 두 시선이 얼마나 차이 나는 지 알 수 있다

      두 벡터 사이의 각도를 통해 Intensity 를 계산할 수 있다
         1. 완전히 빛을 100 % 받거나
         2. 조금이라도 받을 수 있거나
         3. 아예 받지 못하거나

   3. Diffuse Color
      프레그먼트의 Diffuse Color 와 빛의 Diffuse Color 를 이용하여 최종 Diffuse 를 결정
      프레그먼트에 들어오는 빛의 총량에 의해 세기 결정

      프레그먼트의 노멀벡터와
      프레그먼트에서 광원을 바라보는 빛 벡터 사이의
      내적 => 각도에 의해서 결정된다
      최소 0 의 값을 가짐

   4. Specular Color
      반사 빛
      프레그먼트에서 카메라를 향하는 벡터와
      빛이 프레그먼트에서 반사돼서 나가는 벡터를 서로 비교
      두 벡터의 각이 작을 수록, 카메라로 들어가는 반사 빛이 많다
      = Specular Color 가 크다

2. 그냥 바닥이 아니고, 점프 맵을 추가
   1. 원하는 대로 제대로 Collision 이 판단이 되는 지 확인
3. 닿았을 때 바닥에서 시간 재고 => 이후 Map 에서 사라지는 것 까지 구현



4. O(n) 으로 충돌을 찾지 않고, Hash Map 을 이용해서 빠르게 충돌 가능성이 있는 Floor 를 찾기
   1. 해시맵이 아니면, 이진트리?
   2. 어차피 모든 floor 들이 같은 크기를 가지고, 다른 위치만 가진다고 가정한다면
   3. 트리구조를 활용 => 특정 구역에 몰려 있는 floor 들을 모아서 정리한다
   4. 메인 캐릭터 위치에서 충돌 가능성이 있는 구역을 찾고
   5. 해당 구역 내에 저장된 floor 에 대해서만 검색하도록 진행


================
이후에 gpu instancing 진행
다량을 한번에 그려내고
각 객체에 셰이더 id 를 통해서 접근
닿은 객체에 대해서만 투명 => 사라지는 함수 구현




=================
여러 개의 레벨을 생성
간단한 플레이 완성